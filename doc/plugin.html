<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>The SPOCP plugin manual</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.0  (Linux)">
	<META NAME="CREATED" CONTENT="20040428;13512000">
	<META NAME="CHANGEDBY" CONTENT="Eva Magnusson">
	<META NAME="CHANGED" CONTENT="20040428;15222500">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>The SPOCP plugin developers manual</H1>
<P>Document Status: Project document, last update 2004-04-28 <BR>Author:
Roland Hedberg 
</P>
<H2>Content</H2>
<OL>
	<LI><P STYLE="margin-bottom: 0in"><A HREF="#intro">Introduction</A> 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Boundary conditions definitions in
	rules</P>
	<LI><P STYLE="margin-bottom: 0in">Function prototype</P>
	<LI><P STYLE="margin-bottom: 0in">Module format</P>
	<LI><P STYLE="margin-bottom: 0in">APIs</P>
</OL>
<H2><A NAME="intro"></A>0. Introduction</H2>
<P>Much of the power in SPOCP sits in the backends. It is here that
the boundary conditions are evalutated and all the connection to
external information resources are handled. 
</P>
<P>If the doxygen information is built then you can find more
detailed information on functions and structs there.</P>
<H2>1. Boundary condition definitions in rules</H2>
<P>The boundary condition definitions follows a specific format:</P>
<PRE STYLE="margin-bottom: 0.2in">bcond      = pname &quot;:&quot; *unitsel &quot;:&quot; pspec</PRE><P>
Where <I>pname </I>is the name of the plugin, <I>unitsel</I> is
specification of which pieces of information that should be gotten
from the query S-expression. And <I>pspec</I> is information given
using a format that is specific to this plugin.</P>
<H2>2. Function Prototype</H2>
<P>All the plugin function follows the same format:</P>
<PRE STYLE="margin-bottom: 0.2in">spocp_result_t befunc( cmd_param_t *, octet_t *);</PRE><P>
Where the structure cmd_param_t has the elements: 
</P>
<DL>
	<DT><B>element_t *q</B></DT><DD>
	Parsed version of the query S-expression 
	</DD><DT>
	<B>element_t *r</B></DT><DD>
	Parsed version of the S-expression of the matching rule</DD><DT>
	<B>element_t *x</B></DT><DD>
	The result of applying the variable extraction expressions ( <I>unitsel</I>
	mentioned above ) on the query S-expression. 
	</DD><DT>
	<B>octet_t *arg</B></DT><DD>
	The plugin specific part ( <I>pspec</I> above ) of a boundary
	definition 
	</DD><DT>
	<B>pdyn_t *pd</B></DT><DD>
	A structure that holds information needed for caching and backend
	connection pool handling 
	</DD><DT>
	<B>void *con</B></DT><DD STYLE="margin-bottom: 0.2in">
	A pointer to something the plugin has created to store plugin
	specific information 
	</DD></DL>
<P>
And the octet_t struct is where the plugin should place dynamically
produced blobs.</P>
<H2>3. Module format</H2>
<P>We are using a similar format to what Apache is using that is the
plugin source file must contain information about the plugin
functions, both the two basic ( the test and the initialization
functions ) as well as the ones that should be used to handle plugin
configuration directives for this plugin.</P>
<P>Snippet from the foobar plugins source file:</P>
<PRE>spocp_result_t foobar_test( cmd_param_t *cpp, octet_t *blob)
{
....
}

spocp_result_t foofunc( void **conf, void *cmd_data, int argc, char **argv)
{
....
}

conf_com_t conf = {
 { &ldquo;foo&rdquo;, foofunc, NULL, &ldquo;This is the function handling the foo directive&rdquo; },
 NULL
};

plugin_t        foobar_module = {
	SPOCP20_PLUGIN_STUFF,
	foobar_test,
	foobar_init,
	conffunc
};</PRE><H2>
4. APIs</H2>
<P>Almost all of the backends need the same support from the server
and also has similar needs when dealing with connections to external
resources and caching previous results from evaluations. This is the
reason to why we have created a set of APIs for the use by the
backends. 
</P>
<P>Check the doxygen documentation for specifics on the APIs.</P>
<P><BR><BR>
</P>
</BODY>
</HTML>