<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>Creating rules</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.0  (Linux)">
	<META NAME="CREATED" CONTENT="20040223;15282400">
	<META NAME="CHANGEDBY" CONTENT="Eva Magnusson">
	<META NAME="CHANGED" CONTENT="20040223;15562900">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>Creating rules</H1>
<P>Document Status: Project document, last updated
2003-10-02<BR>Authors: Roland Hedberg and Torbj&ouml;rn Wiberg 
</P>
<H2>Content</H2>
<UL>
	<LI><P STYLE="margin-bottom: 0in">0. Introduction 
	</P>
	<LI><P STYLE="margin-bottom: 0in">1. <A HREF="#syntax">The rule
	syntax</A> 
	</P>
	<LI><P STYLE="margin-bottom: 0in">2. <A HREF="#meaning">The meaning
	of a S-expression</A> 
	</P>
	<LI><P>3. <A HREF="#apprule">How to define the rule syntax for a
	application</A> 
	</P>
</UL>
<H2><A NAME="intro"></A>0. Introduction</H2>
<P>A cornerstone of this project, is that anything that is not
<EM>explicitly</EM> permitted is prohibited. 
</P>
<P>Also, there is no such thing as a negative rules. If you by
negative rules means rules that would allow you to limit the scope of
one rule by another. Rules can only be positive; that is grant
someone a permission. 
</P>
<P>When a query about a permission is posed to the system, the system
will search for a rule that permits the action. If <EM>one</EM> such
rule is found the system will stop there. It will <EM>not</EM>
collect all the rules that permits a certain action, one is enough.
Therefore if you have overlapping rules you can not be certain about
which rule the system will use to grant the request. 
</P>
<P>It is possible to couple information to a rule, such that if a
query is granted based on a rule and there is information coupled to
that rule, that information will be returned to the client together
with the positive response. If you use this feature having
overlapping rules might be a really bad thing. 
</P>
<P>When constructing a new rule syntax there are basically three
things you have to answer: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">What do you want to express with
	the rules ? 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Which information does the
	application have or can get access to when it wants to ask the Spocp
	server ? 
	</P>
	<LI><P>Which information resources can the policy engine use to
	evaluate boundary conditions ? 
	</P>
</UL>
<P><EM><U>Note</U></EM> throughout this document the advanced form of
<A HREF="#s-exp">S-expressions</A> will be used since they are much
easier to read for a human. Be aware though that rules that is for
server consumption <B>must</B> be in the canonical form. There exist
a tool in the distribution that can convert from advanced to
canonical form. 
</P>
<P><EM><U>Note also</U></EM> if you have not read <A HREF="draft-hedberg-spocp-sexp-00.html">Introduction
to S-expressions</A> yet you should definitely do so before
continuing with this document. 
</P>
<H2><A NAME="syntax"></A>1. The rule syntax</H2>
<P>The Spocp project has chosen a basic rule syntax. This doesn't
mean that it is set in stone, you might tamper with it if you feel
that your application would benefit from another structure. The
policy engine as implemented will work with any type of rule syntax
as long as it adheres to the syntax of a restricted S-expression as
specified in the <A HREF="draft-hedberg-spocp-sexp-00.html">introduction
to S-expressions</A> document. Still every example provided in this
document or the companion documents will use our structure. 
</P>
<P>The syntax chosen by the project divides the rules into three
parts: 
</P>
<DL>
	<DT STYLE="margin-bottom: 0.2in"><B>Resource</B></DT><DD STYLE="margin-bottom: 0.2in">
	A description of the resource this rules governs access to 
	</DD></DL>
	<DL>
	<DT>
	<B>Action</B></DT><DD STYLE="margin-bottom: 0.2in">
	The action someone/something wants to perform on the resource 
	</DD></DL>
	<DL><DT><B>Subject</B></DT><DD STYLE="margin-bottom: 0.2in">
	The agent that wants to perform the action on the resource and the
	environment the agent appears in 
	</DD></DL>
<P>
It might be important at this point to stress the fact that the
policy engine as implemented only cares about the syntax of the
rules, it has no and should not have any idea about the semantics of
the rules and queries. It just compares S-expressions. 
</P>
<P>So if you are having problems deciding where in the rule syntax a
certain information piece should fit. Whether it should be part of
the resource description or action description for instance. Be
certain that it's only your feeling for aesthetics that might be
disturbed, the policy engine could not care less. 
</P>
<P>With that out of the way, an example what a rule/query can look
like: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(spocp (resource &quot;/etc/passwd&quot;)(action write)(subject (uid 0)))</PRE><P>
Which as a rule would mean that a user with uid 0 on a system has the
right to write to a a file by the name &quot;/etc/passwd&quot;. And
if this where the only rule that deals with write access to
&quot;/etc/passwd&quot; the user with uid 0 is supposed to be the
only one that can write to this file. Whatever 'write' might mean to
the application that handles this resource. 
</P>
<H2><A NAME="meaning"></A>2. The meaning of a S-expression</H2>
<P>As specified in <A HREF="draft-hedberg-spocp-sexp-00.html">introduction
to S-expressions</A> a list that contains more elements than another
is considered more specific or less permissive. 
</P>
<P>This feature make it very easy to construct rules for things that
are hierarchically organized. 
</P>
<P>A file system for instance is hierarchical, therefore a file with
the name &quot;/etc/passwd&quot; is supposed to reside in a directory
by the name &quot;/etc&quot;.<BR>As a S-expression &quot;/etc/passwd&quot;
could be express as &quot;(file etc passwd)&quot; and with the
ordering of S-expressions &quot;(file etc passwd)&quot; is more
specific than &quot;(file etc)&quot;. If one generalizes this, &quot;(file
etc)&quot; is in fact, a shorter way of saying every file and
directory below and including &quot;etc&quot;. 
</P>
<P>This is an important point; <B>rules are always inclusive</B>. 
</P>
<P>An example: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(spocp (resource etc)(action read)(subject))</PRE><P>
As a rule would mean that any subject has read access to everything
below and including the &quot;/etc&quot; directory. 
</P>
<P>A query of the form : 
</P>
<PRE STYLE="margin-bottom: 0.2in">(spocp (resource etc pam.d useradd)(action read)(subject (uid 501) (gid 100)))</PRE><P>
Would therefore get the answer that that subject was permitted to
perform the action. 
</P>
<P>If the rule instead was defined as: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(spocp (resource &quot;/etc&quot;)(action read)(subject))</PRE><P>
Then the query: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(spocp (resource &quot;/etc/pam.d/useradd&quot;)(action read)(subject (uid 501) (gid 100)))</PRE><P>
Would get a negative response. The resources as specified, according
to the way S-expressions are compared, are unequal and
&quot;/etc/pam.d/useradd&quot; is not considered to be more specific
than &quot;/etc&quot; . It is just different. 
</P>
<H2><A NAME="apprule"></A>3. How to define the rule syntax for a
application 
</H2>
<P>In order to choose a rule syntax you have to know certain things
about a application. Very basically you have to know: 
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0in">What policies do you want to be
	able to express ? 
	</P>
	<LI><P STYLE="margin-bottom: 0in">What kind of information does the
	application have access to ? 
	</P>
	<LI><P>What kind of information might the policy engine have access
	to ? 
	</P>
</UL>
<P>Exactly how you then construct the syntax depends on the answers
to these questions. Of course you might also find out that the
information that are present today is not enough to allow you to
express the policies you want. In this case you have to decide where
and how the extra information should be stored, accessed and
maintained. 
</P>
<P>It is very hard to give guidance for rule construction without
grounding these in real examples. So I will provide you with some
guidance by given two examples on how to construct a rule syntax for
a application. The syntax construction examples given below can apart
from describing the constructions as such also be seen as examples of
a methodology. 
</P>
<H3><A NAME="mailserver"></A>3.1 The rule syntax for a mail server</H3>
<H4><A NAME="mailexp"></A>3.1.1 What should be expressed</H4>
<P>As discussed in <A HREF="#rfc2476">RFC 2476</A> : 
</P>
<P>&quot;Message Submission Agents (MSAs) and Message Transfer Agents
(MTAs) MAY implement message rejection rules that rely in part on
whether the message is a submission or a relay.&quot; 
</P>
<P>For example, some sites might configure their MTA to reject all
RCPT TOs for messages that do not reference local users, and
configure their MSA to reject all message submissions that do not
come from authorized users, based on IP address, or authenticated
identity. 
</P>
<P>Starting with these thoughts there are a couple of things you
would like to express: 
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0in">Only allow mails from 'local
	users' 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Only allow mails to 'local users' 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Restricted senders should only be
	allowed to send to certain addresses 
	</P>
	<LI><P STYLE="margin-bottom: 0in">Restricted receivers should only
	be allowed to receive from certain addresses 
	</P>
	<LI><P>Certain senders should never be allowed 
	</P>
</OL>
<P>I am not saying that this is the exact order that you should do
the policy evaluation, or for that matter that this is a exhaustive
list. Depending on the MTA implementation and the rule syntax chosen
you might have to choose another order. The ordering is only there so
I can reference them later in the text. 
</P>
<H4><A NAME="mailinfo"></A>3.1.2 Information the mail server has</H4>
<P>Through the interaction with the sending client, the mail server
has the ipaddress of the sending machine and possibly the host name
of it too. If <A HREF="#rfc2554">SMTP AUTH</A> has been used it will
also have authentication information, like which mechanism that was
used and of course if the sending MTA is among the allowed senders.
<BR>Through the SMTP negotiation it will have information about the
sender email address as well as the receiver/receivers. 
</P>
<P>In case the Spocp is not used to decide which MTAs this MTA should
talk to then the MTA will probably also have a list of MTAs it is
allowed to talk to. Or no such list if it is free to talk to anyone. 
</P>
<H4><A NAME="mailserver2"></A><A NAME="mailserver1"></A>3.1.3
Information the policy sever could access 
</H4>
<P>Depending on your setup the policy server and/or the mail server
can have access to any number of information resources like the
Enterprise directory, Realtime Blackhole Lists (RBLs) and so on. 
</P>
<H4><A NAME="mailsyntax"></A>3.1.4 The syntax</H4>
<P>A attempt at a syntax could then be: 
</P>
<PRE>  syntax = &quot;(spocp (resource &quot; resource &quot;)(action &quot; action &quot;)(subject &quot; subject &quot;))&quot;

  resource = &quot;mailrelay&quot;
  action   = &quot;rcpt (domain &quot; domain &quot;)(local &quot; localpart &quot;)&quot;
  subject  = &quot;(from &quot; sender &quot;)(mta&quot; ipaddr &quot;)(auth&quot; meth &quot;)&quot;</PRE><P>
Query example: 
</P>
<PRE>(spocp
  (resource mailrelay)
  (action rcpt (domain catalogix.se)(local roland))
  (subject (from leifj@it.su.se)(mta 130.237.35.23)(auth cram-md5))
)</PRE><P>
Now it is quite unpractical to construct mailrelay rules for every
allowed combination of senders and receivers. It might be possible if
your MTA is supposed to handle a very small set of users. But we are
dealing with even a medium sized organization it would definitely be
a bad idea. 
</P>
<P>So what you probably would want to do is to use &quot;boundary
conditions&quot;; external tests that will tell you if a certain
email address belongs to a 'local user' or not. <BR>If your
organization has a Enterprise Directory such a test could be: if
there is a entry in the Enterprise Directory who has the email
address, I am interested in, as the value of the mail attribute, then
that email address is regarded as belonging to a local user. 
</P>
<P>Using the ldapset boundary condition this could be expressed as: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(* bcond ldapset:&lt;ldaphost&gt;;&lt;userDN&gt;;\0$mail &amp; ${local}@${domain})</PRE><P>
Where &lt;ldaphost&gt; is the name of the ldap host that has your
enterprise directory, and &lt;userDN&gt; is the starting point of the
subtree that holds your user entries. 
</P>
<P>For my company the boundary condition would be: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(* bcond ldapset:ldap.catalogix.se;cn=person,dc=catalogix,dc=se;\0$mail &amp; ${local}@${domain})</PRE><P>
So now I have a way of expressing the first two rules in 3.1.1 namely
as: &quot;Only allow mails from local user&quot; 
</P>
<PRE>(spocp
  (resource mailrelay)
  (action 
    (* bcond ldapset:ldap.catalogix.se;cn=person,dc=catalogix,dc=se;\0$mail &amp; ${local}@${domain})
  )   
)</PRE><P>
and &quot;only allow mail to local users&quot; 
</P>
<PRE>(spocp
  (resource mailrelay)
  (action )
  (subject
    (* bcond ldapset:ldap.catalogix.se;cn=person,dc=catalogix,dc=se;\0$mail &amp; ${from})
  )   
)</PRE><P>
One of the benefits of using &quot;boundary conditions&quot; like
this is that you can get away with a very small set of rules, who are
very stable, and that you can manage access to any number of
applications by normal administration of the enterprise directory. 
</P>
<P>The last test of 3.1.1 is probably two tests, one against
something like the <A HREF="http://mail-abuse.org/rbl/">Realtime
Blackhole List</A> and another based on the sender email address. The
list of email address that should be block could be gotten from a
spam filters and/or lists that is maintained by your organization.
How you got your hands on it is something I am not going to bother
about, the only interesting thing is that you have by some means put
such a list together. 
</P>
<P>So if you want to use RBL the distribution contains a RBL backend
which allows you to write tests like: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(* bcond rbl:blackholes.mail-abuse.org:${mta})</PRE><P>
If you want to use the publicly available RBL DNS service. There is
nothing though that prohibits you from choosing another similar DNS
service run by your own organization or some other organization by
defining another domain name. 
</P>
<P>When it comes to matching mail address the ldapset boundary
condition is not very suited for handling that. The ldapset boundary
condition can only use exact matches, and for matching email
addresses you most certainly would like to use substring matches. 
</P>
<P>For the same reason GDBM is probably not a god choice, since key
matching in GDBM is also based on exact matching. 
</P>
<P>So you need a type of backend that allows matching on the whole
address, only the domain part, only the top domain, the top domain
plus the sub domain below that or something similar. 
</P>
<P>Luckily the distribution has such a backend, the addrmatch
backend: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(* bcond addrmatch:&lt;filename&gt;:&lt;mail address&gt;)</PRE><P>
This backend allows you to match email address against a file which
contains definitions of whole or parts of mail address you do not
want to allow relaying from. The backend does what is called trailing
substring matches. 
</P>
<P>This backend can also be used when you want to handle the
restricted sender/receiver cases. My guess is that the set of
restricted users are very limited or that you can group them in
groups which can be dealt with as a whole. 
</P>
<P>Typical examples of restricted senders could be students at a
university who has misbehaved and therefore is not allowed full
access to the Internet, but they should still be able to fulfill
there assignments as students which means that they must be able to
send emails to their teachers. 
</P>
<P>A restricted receiver could instead be a email address which in
fact is a gateway to another transport system like a email to
fax-/sms-/.. gateway, which since it possibly involves costly usage
should be limited to a restricted set of users. 
</P>
<P>Restrictions on a email to fax gateway could then be expressed as:
</P>
<PRE>(spocp
  (resource mailrelay)
  (action rcpt (* bcond addrmatch:local_tcpint:${domain}))
  (subject (* bcond addrmatch:faxsenders:${from}))
)</PRE><P>
Where &quot;local_tcpint&quot; would contain a list of the telephone
numbers, in tcp.int format, that the gateway are allowed to contact
given that the sender mail address matches any of the mail address
specifications that exists in &quot;faxsenders&quot;. 
</P>
<H3><A NAME="mailserver4"></A><A NAME="mailserver3"></A>3.2 The rule
syntax for a PAM module</H3>
<P>Pluggable Authentication Module (PAM) is a system of libraries
that handles the authentication task of applications on a system. The
library provides a a stable general interface that privilege granting
programs might defer to to perform standard authentication tasks. 
</P>
<H4><A NAME="mailexp2"></A><A NAME="mailexp1"></A>3.2.1 What should
be expressed</H4>
<P>The PAM module as implemented is supposed to handle the account
aspect of a restricted service. It must therefore know who the user
is, if it's a local or a network based request. And of course it has
to know which service on which host the verification should be
required for. 
</P>
<H4><A NAME="mailinfo2"></A><A NAME="mailinfo1"></A>3.2.2 Information
the a process has</H4>
<P>According to the PAM documentation, the PAM module will have
access to the following variables: 
</P>
<DL>
	<DT>service 
	</DT><DD>
	The name of the application (service) the user wants to access 
	</DD><DT>
	host 
	</DT><DD>
	host address of the host where the request originated 
	</DD><DT>
	uid 
	</DT><DD>
	The user id of the user who wants access 
	</DD><DT>
	gid 
	</DT><DD>
	Group Id of the user 
	</DD><DT>
	port 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Which tty the user is connected to 
	</DD></DL>
<H4>
<A NAME="mailserver6"></A><A NAME="mailserver5"></A>3.2.3 Information
the policy sever could access 
</H4>
<P>If the policy server is running on the same machine it might have
access to &quot;/etc/passwd&quot; and &quot;/etc/groups&quot;. If NIS
is used it could probably get access through that interface. 
</P>
<H4><A NAME="mailinfo4"></A><A NAME="mailinfo3"></A>3.2.4 The PAM
rule syntax</H4>
<P>A proposal could be: 
</P>
<PRE>  syntax = &quot;(spocp (resource &quot; resource &quot;)(action &quot; action &quot;)(subject &quot; subject &quot;))&quot;

  resource = host
  action   = service
  subject  = &quot;(uid &quot; uid &quot;)(gid&quot; gid &quot;)(port&quot; port &quot;)&quot;</PRE><P>
Query example: 
</P>
<PRE>(spocp
  (resource theano.catalogix.se)
  (action useradd)
  (subject (uid 501)(gid 100)(port pts/2))
)</PRE><P>
What more could be done ? Well, you could add time constraint, say
that the useradd command could only be run during normal working
hours ( whatever that might be ). If normal working hours was between
08.00 an 17.00 Monday to Fridays, one would express this with the
time backend: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(* bcond time:;;12345;08:00:00;17:00:00)</PRE><P>
Where you would add such a test is a matter of taste, I see two
possibilities either directly following 'action' or in &quot;subject&quot;
after the user sublist. 
</P>
<P>Now some holidays does not fall on Saturday and Sundays, so
supposing you have a list of those you could have a backend ( there
is none of that kind in the distribution ) that compares the present
date with dates listed as holidays. Adding that boundary condition
would ascertain that the working day definition is more correct. 
</P>
<P>If you wanted to couple the usage of a service to a certain role
within the organization then you, supposing that the uid of a user on
the system was stored in the enterprise directory, could add a
ldapset boundary condition along these lines: 
</P>
<PRE STYLE="margin-bottom: 0.2in">(* bcond ldapset:&lt;ldaphost&gt;;&lt;roleEntry&gt;;&lt;personSubtree&gt;;\0/roleoccupant &amp; [\1%uid &amp; ${uid}])</PRE><P>
Where &quot;roleEntry&quot; would be the specific entry of object
class role that represents the role who should be able to run use the
service. 
</P>
<P>Now, in big organizations the uid is probably not unique over
machines for a specific user. In which case you either have to use
the user name, which has a greater probability of being unique, or a
combination of host name and uid. 
</P>
<H3><A NAME="ref"></A>4. Summary</H3>
<P>I have only scratched on the surface here of what is possible to
do when it comes to deciding on a rule syntax. What I hope has come
through though is that you have to decided on what you want to
express and what kind of information about the user and the her
environment that is to be used to distinguish between different users
under the prevailing circumstances. 
</P>
<P>I would also like to stress the point that using boundary
conditions will allow you to manage access to resources by managing
for instance the enterprise directory. To a cost to be sure, using
boundary conditions always inflicts a performance penalty. But the
ease of management might tip the scale. 
</P>
<P>Using boundary condition will also allow you to write rules that
you probably never will have to change. 
</P>
<H3><A NAME="ref1"></A>5. References</H3>
<DL>
	<DT><A NAME="rfc2476"></A>[RFC2476] 
	</DT><DD>
	R. Gellens and J. Klensin, Message Submission, RFC 2476, December
	1998 
	</DD><DT>
	<A NAME="rfc2554"></A>[RFC2554] 
	</DT><DD>
	J. Myers, SMTP Service Extension for Authentication, RFC 2554, March
	1999 
	</DD><DT>
	<A NAME="s-exp"></A>[S-expressions] 
	</DT><DD>
	Ron Rivest, &quot;S-Expressions&quot;, draft-rivest-sexp-00.txt, May
	1997, &lt;http://theory.lcs.mit.edu/~rivest/sexp.txt&gt;. 
	</DD><DT>
	[S-expressions code and description] 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Ron Rivest, code and description of S-expressions,
	&lt;http://theory.lcs.mit.edu/~rivest/sexp.html&gt;. 
	</DD></DL>
</BODY>
</HTML>
