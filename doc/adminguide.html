<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE>SPOCP Administrators manual</TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.1.0  (Linux)">
	<META NAME="CREATED" CONTENT="20040415;7592800">
	<META NAME="CHANGEDBY" CONTENT="Eva Magnusson">
	<META NAME="CHANGED" CONTENT="20040422;16565600">
</HEAD>
<BODY LANG="en-US" DIR="LTR">
<H1>SPOCP Administrators manual</H1>
<P>Document Status: Project document, last updated
2004-02-23<BR>Authors: Roland Hedberg and Torbj&ouml;rn Wiberg 
</P>
<H1>Content</H1>
<OL START=0>
	<LI><P STYLE="margin-bottom: 0in"><A HREF="#intro">Introduction</A> 
	</P>
	<LI><P STYLE="margin-bottom: 0in"><A HREF="#native">Configuring the
	SPOCP server</A> 
	</P>
</OL>
<H1><A NAME="intro"></A>0. Introduction</H1>
<P>This document assumes some basic knowledge on how S-expressions
are used to manage authorization. If you know very little about this
you would do well to read <A HREF="draft-hedberg-spocp-sexp-00.html">Introduction
to S-expressions</A> before you dwell deeper into this document.<BR>The
next thing is that you will probably not be interested in all of this
document since someone already have decided which authorization setup
you should use. If you are still with me at
this point you are definitely interested in how to set up a
authorization system for you application. So after reading through
<A HREF="rules.html">creating rules</A> you can skip to the section
that deals with your specific setup.</P>
<P>Through out this document I will use the canonical S-expression
format when describing exactly what is produced. In duscussions on
transformations in some case I have choosen to use the advanced
format since that is easier to read. 
</P>
<P>The server loads the rules it is
going to start with from a textfile when starting. If you are
not using the administrative interface to keep the rules updated, you
have to modify the text file and then restart the server when you
want to update the rule set. 
</P>
<p><em>Note:</em> If you are using a persistent datastore for the rules that
will be used and the rule file defined in the configuration will silently be
ignored</p>
<H1><A NAME="native"></A>1. Configuring the SPOCP serve</H1>
<H2>1.0 Introduction</H2>
<P>The Spocd server can listen on Internet ports as well as unix
domain sockets and as protocol it can presently only use TCP. In the
future UDP might also be supported. 
</P>
<H2>1.1 Configuration file</H2>
<H3>1.1.0 Server part</H3>
<P>The server has to know a couple of things when it starts and these
things are supposed to be learnt from the configuration file. If the
configuration file is 'empty' it has some default values for some of
the configurable things.<BR>The format of the configuration file is
as follows: 
</P>
<PRE>  file    = [servercnf] [dbackcnf] *plugincnf

  servercnf   = &ldquo;[server]&rdquo; CRLF *srvassgn

  srvassgn   = srvkeyword *SP &ldquo;=&rdquo; *SP value CRLF

  srvkeyword = &quot;calist&quot; / &quot;certificate&quot; / &quot;dhfile&quot;
           / &quot;entropyfile&quot; / &quot;logfile&quot; / &quot;passwd&quot; / &quot;port&quot;
           / &quot;privatekey&quot; / &quot;rulefile&quot; / &quot;threads&quot; / &quot;timeout&quot;
           / &quot;unixdomainsocket&quot; / &quot;sslverifydepth&quot; / &quot;pidfile&quot;


  dbackcnf   = &ldquo;[dback]&rdquo; CRLF dbackassgn

  dbackassgn = name load *assignment

  name       = &ldquo;name&rdquo; *SP &ldquo;=&rdquo; *SP string CRLF
  load       = &ldquo;load&rdquo; *SP &ldquo;=&rdquo; *SP string CRLF
  poolsize   = &ldquo;poolsize&rdquo; *SP &ldquo;=&rdquo; *SP number CRLF
  cachetime  = &ldquo;cachetime&rdquo; *SP &ldquo;=&rdquo; *SP number CRLF

  plugincnf = &quot;[&quot; string &quot;]&quot; CRLF load [poolsize] [cachetime] *assignment

  assignment = string &ldquo;=&rdquo; 1*UTF8 CRLF

  CRLF       = %x0D [ %x0A ]

  SP         = %x20 / %x09

  digit      = %x30-39
  number     = 1*digit

  string     = 1*printable
  printable  = digit / %x41-5A / %x61-7A

  UTF8    = %x01-09 / %x0B-0C / %x0E-7F / UTF8-2 / UTF8-3 / UTF8-4 / UTF8-5 / UTF8-6
  UTF8-1  = %x80-BF
  UTF8-2  = %xC0-DF UTF8-1
  UTF8-3  = %xE0-EF 2UTF8-1
  UTF8-4  = %xF0-F7 3UTF8-1
  UTF8-5  = %xF8-FB 4UTF8-1
  UTF8-6  = %xFC-FD 5UTF8-1</PRE>
<DL>
	<DT>
	<B>calist</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	File of PEM-encoded Server CA Certificates that can be used to
	verifiy client certificates 
	</DD><DT>
	<B>certificate</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	The file that contains the signed certificate that belongs to the
	SPOCP server 
	</DD><DT>
	<B>dhfile</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	A Diffie-Hellman parameter file 
	</DD><DT>
	<B>entropyfile</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	A file which can be used to feed the randomness function. On a Linux
	system that has been running for a while this is almost never
	needed. 
	</DD><DT>
	<B>logfile</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Where SPOCP should write the logfile entries 
	</DD><DT>
	<B>load</B></DT><DD STYLE="font-weight: medium">
	Where the library is that should be loaded</DD><DD STYLE="font-weight: medium">
	<BR>
	</DD><DT>
	<B>name</B></DT><DD STYLE="font-weight: medium">
	Under which name this plugin should be known.</DD><DD STYLE="font-weight: medium">
	<BR>
	</DD><DT>
	<B>passwd</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	The password necessary to unlock the private key of the SPOCP
	server. If this not provided and the private key is protected by a
	password then the server will ask for the password on startup.
	Something which might be feasible/necessary/correct in some
	circumstances. In others it is completely unworkable 
	</DD><DT>
	<B>pidfile</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Where the server should write the process Id of the server 
	</DD><DT>
	<B>port</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Which Internet port SPOCP should listen on. If this keyword is
	defined the keyword &quot;unixdomainsocket&quot; must not be defined
	and vice versa. 
	</DD><DT>
	<B>privatekey</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	The file that contains the privatekey that should be used by this
	SPOCP server, this file can be the same as the one specified for the
	certificate. But we strongly discourage this practice. Instead we
	recommend you to separate the Certificate and the Private Key 
	</DD><DT>
	<B>rulefile</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Where the file containing the SPOCP rules are placed. 
	</DD><DT>
	<B>sslverifydepth</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	From the OpenSSL documentation: This directive sets how deeply
	mod_ssl should verify before deciding that the clients don't have a
	valid certificate. 
	</DD><DD STYLE="margin-bottom: 0.2in">
	The depth actually is the maximum number of intermediate certificate
	issuers, i.e. the number of CA certificates which are max allowed to
	be followed while verifying the client certificate. A depth of 0
	means that self-signed client certificates are accepted only, the
	default depth of 1 means the client certificate can be self-signed
	or has to be signed by a CA which is directly known to the server
	(i.e. the CA's certificate is under). Default is 1.</DD><DT>
	<B>threads</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	The number of threads the server will use to service requests. This
	number is static, that is it will not change over time depending on
	load. Default is 5.</DD><DT>
	<B>timeout</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	The inactivity timeout. If a client has been silent for this long
	(seconds) on a connection the server will unilaterly close down the
	connection. If set to 0, the server will never close the connection
	on a client. Default is 30. 
	</DD><DT>
	<B>unixdomainsocket</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Which unix domain socket spocp should listen on. 
	</DD></DL>
<H3>
1.1.2 Plugin part</H3>
<P>The native server handles what we call boundary conditions through
the use of plugins. Plugins are dynamically loaded software modules
that are loaded at startup. 
</P>
<P>Since we don't know and can't guess what kind of plugins there are
going to be in the future we have only defined how to tell the server
about plugins. 
</P>
<P>As with Apache plugins, the plugin library contains information
about which assignments you can make and what the keywords are.</P>
<P>There are a couple of keys that we have defined that can be used
by all plugins: 
</P>
<DL>
	<DT><B>load</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	The plugin library</DD><DT>
	<B>cachetime</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Definitions of the cachetime for testresults to use for different
	backends.</DD><DT>
	<B>poolsize</B> 
	</DT><DD STYLE="margin-bottom: 0.2in">
	Every plugin can have a connection pool connected to it. It can use
	this pool to store open connections to information resources it uses
	for the future. This instead of closing and opening connections for
	each query. Here you can define how big the pool should be for each
	plugin separately. If you do not define a poolsize for a plugin,
	that plugin will not be able to store connections for later use 
	</DD></DL>
<H3>
1.1.3 Example</H3>
<PRE>[server]
certificate = /usr/local/spocp/certs/spocpserver.pem
privatekey  = /usr/local/spocp/certs/spocpserver.pem
passwd      = NewKey
calist      = /usr/local/spocp/certs/cacert.pem
logfile     = /var/log/spocp
port        = 3456
rulefile    = /usr/local/spocp/pam/rules.pam

[strmatch]
load    =/usr/local/spocp/lib/libstrmatchplugin.so

[dback]
name    =gdbm
load    =/usr/local/spocp/lib/libdbackgdbm.so
gdbmfile=/usr/local/spocp/db/spocp.gdbm</PRE><H3>
1.1.4 Persistent rule store</H3>
<P>If a dback is defined, then if the presistent store is not
initialized the rules are read from the rule file. If on the other
hand it is in existence the rules will be read from the persistent
store and whatever is in the rule file will be ignored. During
operation ir rules are added or deleted the persistent store will be
updated accordingly.</P>
<H2>1.2 Commandline options</H2>
<P>When you start the server you probably want to tell it where to
find the configuration file. The default is to look for a file named
&quot;config&quot; in the directory where you stood when you started
the program. 
</P>
<PRE> spocd [-d num][-f file]
 num   = 1*digit
 digit = %30-39
 file  = 1*UTF8 ; filename</PRE><P>
The '-d' option allows you to decide how much should be logged. It
works like this: 1-7 is the loglevel (0 = ONLY emergencies,...,
7=debug). If you have set DEBUG as the level you can get even more
information by specifying which part of the code that should log
debug information ( 16 = PARSE, 32 = STORE, 64 = MATCH, 128 =
BOUNDARY CONDITIONS and 256 = SERVER ). So 511 should given you
everything it can produce and it's quite a lot. 
</P>
<H2><A NAME="rulefile"></A>1.3 Rulefile format</H2>
<P>A formal definition: 
</P>
<PRE>  line       = ( rule / comment / &quot;&quot; / bconddef / include )
  rule       = sexp [ 1*SP &ldquo;=&gt;&rdquo; 1*SP bcexp] [ 1*SP &ldquo;==&rdquo; 1*SP blob ]
  sexp       = &quot;(&quot; *SP string *( 1*SP element ) *SP &quot;)&quot;
  element    = sexp / atom
  blob       = atom
  atom       = string / quoted-string / hex-string / base64-string
  
  string     = 1*vchar
               ; printable except '&rdquo;', '#', '%', '(', ')', '*', '/', 
               ; '[', '\', ']', '{', '|', '}'
  vhar       = x%21 / x%23 / x%24 / x%26 / x%27 / x%2B-%x2E / x%30-5A / x%5E-7B / x%7E

  quoted-string = '&rdquo;' 1*printchar '&rdquo;'
  printchar     = x%21 / x%23-7E

  comment    = &quot;#&quot; *UTF8 CRLF ; has to be first on the line

  bconddef   = string *SP &quot;:=&quot; *SP bcond
  bcond      = pname &ldquo;:&rdquo; *unitsel &ldquo;:&rdquo; atom

  unitsel    = &ldquo;{&ldquo; 1*path unit &ldquo;}&rdquo;
  path       = &ldquo;/&rdquo; string 
  unit       = ( &ldquo;/*&rdquo; / 
                 &ldquo;[&ldquo; ( num [ &ldquo;-&rdquo; [ num ]] / &ldquo;-&rdquo; num / &ldquo;last&rdquo; ) &ldquo;]&rdquo; )

  SP         = %x20 / %x09                      ; space or tab
  DIGIT      = %x30-39
  num        = *DIGIT
  val        = 1*( UTF8 / pair )

  include    = &quot;;include&quot; filename              ; reference to another rule file

  hex-string = &quot;%&quot; 1*hexpair
  hexpair    = hexchar hexchar
  hexchar    = DIGIT / &quot;A&quot; / &quot;B&quot; / &quot;C&quot; / &quot;D&quot; / &quot;E&quot; / &quot;F&quot;
               / &quot;a&quot; / &quot;b&quot; / &quot;c&quot; / &quot;d&quot; / &quot;e&quot; / &quot;f&quot;

  base64-string = &ldquo;|&rdquo; 1*bchar 1*2&rdquo;=&rdquo;            ; a bit loose
  bchar         = DIGIT / %x41-5A / %x61-7A / %x2B / %x2F

  pname      = 1*pchar
  pchar      = DIGIT / 0x41-5A / 0x61-7A / %x2E

  bcexp      = bcond / bcomp
  bcomp      = and / or / not / ref
  ref        = &quot;(&ldquo; *SP &ldquo;ref&quot; 1*SP pname *SP &quot;)&quot;
  and        = &quot;(&ldquo; *SP &ldquo;and&quot; 2*( 1*SP bcomp ) *SP &quot;)&quot;
  or         = &quot;(&ldquo; *SP &ldquo;or&quot; 2*( 1*SP bcomp ) *SP &quot;)&quot;
  not        = &quot;(&ldquo; *SP &ldquo;not&quot; 1*SP bcomp *SP &quot;)&quot;
  CRLF       = %x0D [%x0A]</PRE><P>
Example of a rulefile: 
</P>
<PRE>strcmp := &quot;strmatch:{//to[1]}{//o[1]}:${0}:${1}&quot;
;include bconddef
#
(
        nya
        AF11_write1
        (
                role
                s
                (
                        *
                        set
                        1
                        2
                )
        )
)

(nya AF11_write2
     (role s 2))
#
(nya AF12_read (role ah (* set 2 3 4 5)))
        == &quot;This is a blob, which is supposted to be turned back with a positive answer&quot;

(nya AF12_write (role ah (* set 4 5)))

(nya AF12_writeO (role ah (* set 4 5)))
#detta &auml;r ett randvillkorsuttryck som h&ouml;r till ovanst&aring;ende rad
        =&gt; (ref strcmp)
#
(nya AF13_read (role ah (* set 2 3 4 5)))
(nya AF13_write (role ah (* set 4 5)))
#
(nya AF13_writeO (role ah (* set 4 5))) =&gt; (ref strcmp) == |Rm9vQmFyCg==
(nya AF41_write (role ah (* set  2 3 4 5)))

# Server and operation access restrictions
//marcia/server/(server( ip(* prefix 213.79.154)))
//marcia/server/(server( ip 127.0.0.1))
//marcia/operation/(operation STARTTLS)
//marcia/operation/(operation QUERY 
    (server (ip)(host)(TransportSec (vers (* set &quot;TLSv1/SSLv3&quot; SSLv3)))))
//marcia/operation/(operation LOGOUT 
    (server (ip)(host)(TransportSec (vers (* set &quot;TLSv1/SSLv3&quot; SSLv3)))))</PRE><P>
<B>Note:</B> Inclusion of other files are done where the reference to
them appear in the text. 
</P>
<P><B>Note:</B> Rules can be divided into rulesets, they way to
ackomplish this is to prepend the ruledefinition itself with a path
name. This is normally not used for application rules but definitely
for the access rules for the Spocp server itself. The default base
for access rules to the Spocp server is &ldquo;/&rdquo;&lt;hostname&gt;&rdquo;/operation&rdquo;
for operation access rules and &ldquo;/&rdquo;&lt;hostname&gt;&rdquo;/server&rdquo;
for access to the server itself. In the example above Spocp clients
with IP addresses 213.79.154/24 or 127.0.0.1 are allowed access to
the Spocp server. These servers has as long as they are not using
SSLv3 not access to any other command than STARTTLS. Using TLS/SSL
they have access to the &ldquo;QUERY&rdquo; and &ldquo;LOGOUT&rdquo;
operations.</P>
<HR>
</BODY>
</HTML>
